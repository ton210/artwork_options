/**
 * Enhanced Product Designer - Complete Merged Version
 * Version: 3.4.2 (Fixed)
 *
 * This is the complete merged version of the Enhanced Product Designer.
 * All modules have been combined into a single file for compatibility.
 *
 * Generated on: 2025-08-04 22:02:33
 * Fixed on: 2025-08-04
 */

// Prevent duplicate loading
if (typeof window.EnhancedProductDesigner === 'undefined') {

// Helper Classes

/**
 * DesignAnalytics Helper Class
 */
class DesignAnalytics {
  constructor() {
    this.events = [];
    this.sessionStart = Date.now();
  }

  track(eventType, data = {}) {
    const event = {
      type: eventType,
      timestamp: Date.now(),
      sessionDuration: Date.now() - this.sessionStart,
      data: data
    };

    this.events.push(event);

    // Send to analytics service if available
    if (window.gtag) {
      window.gtag('event', eventType, {
        event_category: 'Designer',
        event_label: JSON.stringify(data)
      });
    }
  }

  getDesignComplexity(canvas) {
    const objects = canvas.getObjects();
    return {
      totalObjects: objects.length,
      objectTypes: this.countObjectTypes(objects)
    };
  }

  countObjectTypes(objects) {
    const types = {};
    objects.forEach(obj => {
      types[obj.type] = (types[obj.type] || 0) + 1;
    });
    return types;
  }
}

/**
 * ImageLoader Helper Class
 */
class ImageLoader {
  constructor() {
    this.queue = [];
    this.loading = false;
    this.maxConcurrent = 3;
    this.activeLoads = 0;
  }

  // NEW: Create fallback lightbox if the PHP didn't load it
  createFallbackLightbox() {
    console.log('Creating fallback lightbox HTML structure...');

    const lightboxHTML = `
      <div id="designer-lightbox" class="designer-lightbox">
        <div class="designer-modal">
          <div class="designer-header">
            <h2>Customize Design</h2>
            <button class="designer-close">&times;</button>
          </div>
          <div class="designer-loading" style="display: flex;">
            <div class="loading-spinner"></div>
            <p>Loading designer...</p>
          </div>
          <div class="designer-body" style="opacity: 0;">
            <div class="designer-sidebar">
              <div class="tool-section">
                <h3>Add Elements</h3>
                <div class="tool-buttons">
                  <div class="upload-image-btn">
                    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" /></svg>
                    <span>Upload Image</span>
                    <input type="file" class="image-upload-input" accept="image/*" multiple>
                  </div>
                  <button class="add-text-btn tool-btn">
                    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M18.5,4L19.66,8.35L18.7,8.61C18.25,7.74 17.79,6.87 17.26,6.43C16.73,6 16.11,6 15.5,6H13V16.5C13,17 13,17.5 13.5,17.5H14V19H10V17.5H10.5C11,17.5 11,17 11,16.5V6H8.5C7.89,6 7.27,6 6.74,6.43C6.21,6.87 5.75,7.74 5.3,8.61L4.34,8.35L5.5,4H18.5Z" /></svg>
                    <span>Add Text</span>
                  </button>
                </div>
              </div>
              <div class="tool-section">
                <h3>Actions</h3>
                <div class="history-controls">
                  <button id="undo-btn" class="history-btn" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z" /></svg>
                    Undo
                  </button>
                  <button id="redo-btn" class="history-btn" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M18.4,10.6C16.55,9 14.15,8 11.5,8C6.85,8 2.92,11.03 1.53,15.22L3.9,16C4.95,12.81 7.96,10.5 11.5,10.5C13.46,10.5 15.23,11.22 16.62,12.38L13,16H22V7L18.4,10.6Z" /></svg>
                    Redo
                  </button>
                </div>
              </div>
            </div>
            <div class="canvas-container">
              <canvas id="designer-canvas"></canvas>
            </div>
            <div class="properties-panel">
              <h3>Properties</h3>
            </div>
          </div>
          <div class="designer-footer">
            <button class="cancel-design btn btn-secondary">Cancel</button>
            <button class="apply-design btn btn-primary">Apply Design</button>
          </div>
        </div>
      </div>
      
      <!-- Text Editor Modal -->
      <div id="text-editor-modal" class="text-editor-modal">
        <div class="modal-content">
          <h3>Add Text</h3>
          <div class="text-controls">
            <input type="text" id="text-input" placeholder="Enter your text">
            <div class="text-options">
              <select id="font-select">
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Helvetica">Helvetica</option>
              </select>
              <input type="color" id="text-color" value="#000000">
              <input type="range" id="text-size" min="10" max="100" value="30">
              <span id="text-size-value">30px</span>
            </div>
          </div>
          <div class="modal-actions">
            <button id="cancel-text" class="btn btn-secondary">Cancel</button>
            <button id="add-text-confirm" class="btn btn-primary">Add Text</button>
          </div>
        </div>
      </div>
      
      <!-- Hidden inputs for form data -->
      <input type="hidden" id="custom-design-preview" name="custom_design_preview" value="">
      <input type="hidden" id="custom-design-data" name="custom_design_data" value="">
      <input type="hidden" id="custom-canvas-data" name="custom_canvas_data" value="">
    `;

    // Add basic CSS for the fallback lightbox
    const fallbackCSS = `
      <style id="fallback-designer-css">
        .designer-lightbox {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          display: none;
          z-index: 999999;
          align-items: center;
          justify-content: center;
        }
        .designer-modal {
          background: white;
          border-radius: 8px;
          width: 90vw;
          height: 90vh;
          max-width: 1200px;
          display: flex;
          flex-direction: column;
          position: relative;
        }
        .designer-header {
          padding: 20px;
          border-bottom: 1px solid #ddd;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .designer-close {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
        }
        .designer-loading {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          flex-direction: column;
          align-items: center;
        }
        .loading-spinner {
          width: 40px;
          height: 40px;
          border: 4px solid #f3f3f3;
          border-top: 4px solid #0073aa;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 10px;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .designer-body {
          flex: 1;
          display: flex;
          padding: 20px;
        }
        .designer-sidebar {
          width: 250px;
          padding-right: 20px;
          border-right: 1px solid #ddd;
        }
        .canvas-container {
          flex: 1;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 20px;
          position: relative;
        }
        .properties-panel {
          width: 200px;
          padding-left: 20px;
          border-left: 1px solid #ddd;
          display: none; /* Hidden by default on desktop */
        }
        @media (max-width: 768px) {
          .properties-panel.mobile-visible {
            display: block;
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100vh;
            background: white;
            z-index: 1000001;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
          }
        }
        .designer-footer {
          padding: 20px;
          border-top: 1px solid #ddd;
          display: flex;
          justify-content: flex-end;
          gap: 10px;
        }
        .btn {
          padding: 10px 20px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        .btn-primary {
          background: #0073aa;
          color: white;
        }
        .btn-secondary {
          background: #666;
          color: white;
        }
        .tool-btn {
          display: flex;
          align-items: center;
          gap: 8px;
          width: 100%;
          padding: 12px;
          margin-bottom: 8px;
          border: 1px solid #ddd;
          background: white;
          cursor: pointer;
          border-radius: 4px;
        }
        .upload-image-btn {
          position: relative;
          display: flex;
          align-items: center;
          gap: 8px;
          width: 100%;
          padding: 12px;
          margin-bottom: 8px;
          border: 1px solid #ddd;
          background: white;
          cursor: pointer;
          border-radius: 4px;
          overflow: hidden;
        }
        .upload-image-btn input {
          position: absolute;
          opacity: 0;
          width: 100%;
          height: 100%;
          cursor: pointer;
          left: 0;
          top: 0;
        }
        .text-editor-modal {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          display: none;
          z-index: 1000002;
          align-items: center;
          justify-content: center;
        }
        .text-editor-modal .modal-content {
          background: white;
          padding: 20px;
          border-radius: 8px;
          min-width: 400px;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
        }
        .text-editor-modal .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
          padding-bottom: 10px;
          border-bottom: 1px solid #ddd;
        }
        .text-editor-modal .modal-close {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .text-controls {
          margin: 20px 0;
        }
        .text-controls input,
        .text-controls select {
          margin: 5px;
          padding: 8px;
        }
        .modal-actions {
          display: flex;
          justify-content: flex-end;
          gap: 10px;
          margin-top: 20px;
        }
        .history-controls {
          display: flex;
          gap: 5px;
        }
        .history-btn {
          padding: 8px;
          border: 1px solid #ddd;
          background: white;
          cursor: pointer;
          border-radius: 4px;
          font-size: 12px;
        }
        .history-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
      </style>
    `;

    // Add the CSS first
    document.head.insertAdjacentHTML('beforeend', fallbackCSS);

    // Add the HTML to the body
    document.body.insertAdjacentHTML('beforeend', lightboxHTML);

    console.log('Fallback lightbox created successfully');

    // Verify it was created
    const createdLightbox = document.getElementById('designer-lightbox');
    console.log('Fallback lightbox verification:', !!createdLightbox);

    return !!createdLightbox;
  }

  async loadImage(url, options = {}) {
    return new Promise((resolve, reject) => {
      this.queue.push({ url, options, resolve, reject });
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.activeLoads >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }

    const item = this.queue.shift();
    this.activeLoads++;

    try {
      const img = await this.loadImageElement(item.url);
      item.resolve(img);
    } catch (error) {
      item.reject(error);
    } finally {
      this.activeLoads--;
      this.processQueue();
    }
  }

  loadImageElement(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = url;
    });
  }
}

// Main Enhanced Product Designer Class
class EnhancedProductDesigner {
  constructor(config = {}) {
      // Basic configuration
      this.config = config;
      this.canvas = null;
      this.currentVariantId = null;
      this.backgroundImage = null;
      this.maskImage = null;
      this.unclippedMaskImage = null;
      this.backgroundUrl = null;
      this.maskUrl = null;
      this.unclippedMaskUrl = null;

      // History management
      this.history = [];
      this.historyStep = -1;
      this.isRedoing = false;
      this.isReordering = false;
      this.isLoadingDesign = false;

      // Cropping
      this.isCropping = false;
      this.cropper = null;
      this.croppingObject = null;

      // Session and saved designs
      this.savedDesigns = this.loadSavedDesigns();
      this.preservedCanvasData = null;
      this.autoSaveInterval = null;

      // Clipping bounds
      this.clipBounds = null;

      // Quantity and pricing
      this.quantityInfo = null;

      // Analytics
      this.analytics = new DesignAnalytics();

      // Image loader
      this.imageLoader = new ImageLoader();

      // WordPress AJAX configuration
      this.wpAjaxConfig = {
          url: (typeof swpdDesignerConfig !== 'undefined' && swpdDesignerConfig.ajax_url) || '/wp-admin/admin-ajax.php',
          nonce: (typeof swpdDesignerConfig !== 'undefined' && swpdDesignerConfig.nonce) || ''
      };

      // Cloudinary configuration
      this.cloudinaryConfig = (typeof swpdDesignerConfig !== 'undefined' && swpdDesignerConfig.cloudinary) || {
          enabled: false,
          cloudName: '',
          uploadPreset: ''
      };

      // Translations
      this.translations = (typeof swpdTranslations !== 'undefined') ? swpdTranslations : {};

      // Mobile UI elements
      this.mobileDeleteBtn = null;

      // Regenerate callback
      this.regenerateCallback = null;

      // Initialize the designer
      this.init();
  }

  init() {
    // Debug configuration
    console.log('=== DESIGNER INITIALIZATION ===');
    console.log('Config:', this.config);
    console.log('swpdDesignerConfig:', typeof swpdDesignerConfig !== 'undefined' ? swpdDesignerConfig : 'not defined');
    if (typeof swpdDesignerConfig !== 'undefined') {
      console.log('Cloudinary config:', swpdDesignerConfig.cloudinary);
      console.log('AJAX URL:', swpdDesignerConfig.ajax_url);
      console.log('Nonce:', swpdDesignerConfig.nonce);
    }

    // Load required libraries
    Promise.all([
      this.loadFabricJS(),
      this.loadCropperJS(),
    ]).then(() => {
      this.setupCanvas();
      setTimeout(() => {
        this.setupEventListeners();
        this.setupKeyboardShortcuts();
        this.setupAnimations();
        this.checkForEditMode(); // This will now correctly use sessionStorage
        this.initializeNewFeatures();
        this.startAutoSave();
        this.setupMobileUI(); // Updated call
      }, 100);
    }).catch(error => {
      console.error('Failed to load required libraries:', error);
      this.showNotification('Failed to load designer. Please refresh the page.', 'error');
    });
  }

  initializeNewFeatures() {
    try {
      this.setupLayersPanel();
    } catch (error) {
      console.warn('Error setting up layers panel:', error);
    }

    try {
      this.setupAlignmentTools();
    } catch (error) {
      console.warn('Error setting up alignment tools:', error);
    }

    try {
      this.setupAdvancedTextControls();
    } catch (error) {
      console.warn('Error setting up advanced text controls:', error);
    }

    try {
      this.setupProductVariantSelector();
    } catch (error) {
      console.warn('Error setting up product variant selector:', error);
    }

    try {
      this.loadQuantityInfo();
    } catch (error) {
      console.warn('Error loading quantity info:', error);
    }

    try {
      this.setupCanvasControls();
    } catch (error) {
      console.warn('Error setting up canvas controls:', error);
    }

    try {
      this.setupZoomControls();
    } catch (error) {
      console.warn('Error setting up zoom controls:', error);
    }

    try {
      this.setupGridToggle();
    } catch (error) {
      console.warn('Error setting up grid toggle:', error);
    }

    try {
      this.adjustLayoutForDesktop();
    } catch (error) {
      console.warn('Error adjusting layout for desktop:', error);
    }
  }

  setupCanvas() {
    const checkCanvas = () => {
      const canvasElement = document.getElementById('designer-canvas');
      if (canvasElement) {
        const container = document.querySelector('.canvas-container');
        const isMobile = window.innerWidth <= 768;
        let canvasSize = 800;

        if (container) {
          const containerWidth = container.offsetWidth - 40;
          const containerHeight = container.offsetHeight - 40;
          canvasSize = Math.min(containerWidth, containerHeight, 800);
          if (isMobile) {
            canvasSize = Math.max(canvasSize, 280);
          } else {
            canvasSize = Math.max(canvasSize, 500);
          }
        }

        this.canvas = new fabric.Canvas('designer-canvas', {
          backgroundColor: '#f5f5f5',
          preserveObjectStacking: true,
          width: canvasSize,
          height: canvasSize,
          isDrawingMode: false,
          selection: true,
          allowTouchScrolling: isMobile, // Mobile-optimized setting
        });

        const canvasWrapper = this.canvas.wrapperEl;
        if (canvasWrapper) {
          canvasWrapper.style.margin = '0 auto';
          canvasWrapper.style.display = 'block';
          canvasWrapper.style.position = 'relative';
        }

        const canvasContainerDiv = canvasWrapper.parentElement;
        if (canvasContainerDiv) {
          canvasContainerDiv.style.display = 'flex';
          canvasContainerDiv.style.alignItems = 'center';
          canvasContainerDiv.style.justifyContent = 'center';
          canvasContainerDiv.style.width = '100%';
          canvasContainerDiv.style.height = '100%';
        }

        this.canvas.isDrawingMode = false;
        this.canvas.freeDrawingBrush = null;

        fabric.Image.prototype.crossOrigin = 'anonymous';
        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.cornerColor = '#0073aa';
        fabric.Object.prototype.cornerSize = isMobile ? 14 : 12; // Mobile-optimized setting
        fabric.Object.prototype.padding = isMobile ? 8 : 10; // Mobile-optimized setting
        fabric.Object.prototype.borderColor = '#0073aa';
        fabric.Object.prototype.borderDashArray = [5, 5];

        this.canvas.on('object:modified', () => {
          if (!this.isReordering && !this.isLoadingDesign) {
            this.saveHistory();
          }
        });

        this.canvas.on('object:added', (e) => {
          if (!this.isRedoing && !this.isReordering && !this.isLoadingDesign && e.target && e.target.selectable !== false) {
            this.saveHistory();
            this.ensureProperLayering();
          }
        });

        this.canvas.on('object:removed', (e) => {
          if (!this.isReordering && !this.isLoadingDesign && e.target && e.target.selectable !== false) {
            this.saveHistory();
          }
        });

        this.canvas.on('path:created', (e) => {
          if (e.path) {
            this.canvas.remove(e.path);
          }
        });

        this.canvas.on('mouse:down', () => {
          if (this.canvas.isDrawingMode) {
            this.canvas.isDrawingMode = false;
          }
        });

        this.handleResize();
        window.addEventListener('resize', this.debounce(() => this.handleResize(), 250));
      } else {
        setTimeout(checkCanvas, 100);
      }
    };
    checkCanvas();
  }

  handleResize() {
      if (!this.canvas) return;

      const container = document.querySelector('.canvas-container');
      if (!container) return;

      const isMobile = window.innerWidth <= 768;
      // Better mobile calculation: consider padding/margins
      const padding = isMobile ? 20 : 40;
      const containerWidth = container.offsetWidth - padding;
      const containerHeight = container.offsetHeight - padding;
      let canvasSize = Math.min(containerWidth, containerHeight);

      if (isMobile) {
        canvasSize = Math.max(canvasSize, 280);
      } else {
        canvasSize = Math.max(canvasSize, 500);
        canvasSize = Math.min(canvasSize, 800); // Max size on desktop
      }

      const currentSize = this.canvas.width;
      const scaleFactor = canvasSize / currentSize;

      this.canvas.setDimensions({
        width: canvasSize,
        height: canvasSize
      });

      this.canvas.setZoom(this.canvas.getZoom() * scaleFactor);

      if (this.backgroundImage) {
          // Recenter background and mask based on new size
          this.backgroundImage.center();
          if (this.maskImage) {
              this.maskImage.center();
          }
          this.setupMaskClipping(); // Recalculate clipping bounds
      }

      this.canvas.renderAll();
  }

  setupMaskClipping() {
    // Simplified version - no clip guide, just calculate bounds for positioning
    const maskForClipping = this.maskImage;

    if (!this.canvas || !maskForClipping || !this.backgroundImage) {
      console.warn('Cannot setup mask clipping: missing required images');
      return;
    }

    console.log('Setting up mask clipping bounds...');

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = maskForClipping.width;
    tempCanvas.height = maskForClipping.height;
    const ctx = tempCanvas.getContext('2d');

    if (!ctx) {
      console.error('Failed to get 2D context for mask processing');
      return;
    }

    ctx.drawImage(maskForClipping._element, 0, 0);
    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const data = imageData.data;
    let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
    let foundNonTransparent = false;

    for (let y = 0; y < tempCanvas.height; y++) {
      for (let x = 0; x < tempCanvas.width; x++) {
        const alpha = data[(y * tempCanvas.width + x) * 4 + 3];
        if (alpha > 10 || data[(y * tempCanvas.width + x) * 4] > 10) {
          foundNonTransparent = true;
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }

    if (foundNonTransparent) {
      const maskElement = maskForClipping._element;
      const originalMaskWidth = maskElement.naturalWidth;
      const originalMaskHeight = maskElement.naturalHeight;

      const currentScaledMaskWidth = maskForClipping.getScaledWidth();
      const currentScaledMaskHeight = maskForClipping.getScaledHeight();

      const widthRatio = currentScaledMaskWidth / originalMaskWidth;
      const heightRatio = currentScaledMaskHeight / originalMaskHeight;
      const effectiveScale = Math.min(widthRatio, heightRatio);

      const canvasWidth = this.canvas.width;
      const canvasHeight = this.canvas.height;
      const offsetX = (canvasWidth - currentScaledMaskWidth) / 2;
      const offsetY = (canvasHeight - currentScaledMaskHeight) / 2;

      this.clipBounds = {
        left: offsetX + minX * effectiveScale,
        top: offsetY + minY * effectiveScale,
        width: (maxX - minX + 1) * effectiveScale,
        height: (maxY - minY + 1) * effectiveScale,
      };
    }
  }

  saveHistory() {
    const currentObjects = this.canvas.getObjects().filter(obj => obj.selectable !== false);
    const currentState = JSON.stringify({objects: currentObjects.map(obj => obj.toObject(['selectable', 'evented', 'crossOrigin']))});

    if (this.isRedoing || this.isReordering || this.isLoadingDesign) return;

    if (this.historyStep >= 0 && this.history[this.historyStep] === currentState) {
      return;
    }

    this.history = this.history.slice(0, this.historyStep + 1);
    this.history.push(currentState);
    this.historyStep++;
    if (this.history.length > 50) {
      this.history.shift();
      this.historyStep--;
    }
    this.updateHistoryButtons();
    this.saveSessionDesign();
  }

  undo() {
    if (this.historyStep > 0 && this.canvas) {
      this.historyStep--;
      this.isRedoing = true;
      this.canvas.clear();
      this.addFixedLayers();

      const stateToLoad = JSON.parse(this.history[this.historyStep]);

      this.canvas.loadFromJSON(stateToLoad, () => {
        this.canvas.renderAll();
        this.isRedoing = false;
        this.updateHistoryButtons();
        this.ensureProperLayering();
      }, (o, object) => {
        // Custom revive logic if needed
      });
    }
  }

  redo() {
    if (this.historyStep < this.history.length - 1 && this.canvas) {
      this.historyStep++;
      this.isRedoing = true;
      this.canvas.clear();
      this.addFixedLayers();

      const stateToLoad = JSON.parse(this.history[this.historyStep]);

      this.canvas.loadFromJSON(stateToLoad, () => {
        this.canvas.renderAll();
        this.isRedoing = false;
        this.updateHistoryButtons();
        this.ensureProperLayering();
      }, (o, object) => {
        // Custom revive logic if needed
      });
    }
  }

  updateHistoryButtons() {
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');

    const hasUserContentInPrevSteps = this.history.slice(0, this.historyStep).some(stateStr => {
      const state = JSON.parse(stateStr);
      return state.objects.some(obj => obj.selectable !== false);
    });

    if (undoBtn) undoBtn.disabled = !hasUserContentInPrevSteps;
    if (redoBtn) redoBtn.disabled = this.historyStep >= this.history.length - 1;
  }

  fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  checkImageResolution(imgElement, fabricImg) {
    const DPI_THRESHOLD = 72;
    const PIXEL_PER_INCH = 72;

    const productWidthPx = this.clipBounds ? this.clipBounds.width : this.canvas.width;
    const productHeightPx = this.clipBounds ? this.clipBounds.height : this.canvas.height;

    const currentImgScaleX = fabricImg.scaleX || 1;
    const currentImgScaleY = fabricImg.scaleY || 1;

    const effectiveWidthPx = fabricImg.width * currentImgScaleX;
    const effectiveHeightPx = fabricImg.height * currentImgScaleY;

    const approximatePrintWidthInches = effectiveWidthPx / PIXEL_PER_INCH;
    const approximatePrintHeightInches = effectiveHeightPx / PIXEL_PER_INCH;

    const actualDPI_X = imgElement.naturalWidth / approximatePrintWidthInches;
    const actualDPI_Y = imgElement.naturalHeight / approximatePrintHeightInches;
    const effectiveDPI = Math.min(actualDPI_X, actualDPI_Y);

    if (effectiveDPI < DPI_THRESHOLD && effectiveWidthPx > 0 && effectiveHeightPx > 0) {
      const warning = document.createElement('div');
      warning.className = 'low-res-warning';
      warning.innerHTML = `
        <div class="warning-content">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="#ff9800">
            <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
          </svg>
          <span>Low resolution image detected (${Math.round(effectiveDPI)} DPI). May appear blurry when printed.</span>
        </div>
      `;

      const canvas = document.querySelector('.canvas-container');
      if (canvas && !canvas.querySelector('.low-res-warning')) {
        canvas.appendChild(warning);

        setTimeout(() => {
          warning.remove();
        }, 5000);
      }

      fabricImg.set('strokeWidth', 3);
      fabricImg.set('stroke', '#ff9800');
    } else {
      fabricImg.set('strokeWidth', 0);
      fabricImg.set('stroke', '');
      const existingWarning = document.querySelector('.low-res-warning');
      if(existingWarning) existingWarning.remove();
    }
  }

  showTextEditor() {
      const modal = document.getElementById('text-editor-modal');
      if (modal) {
        // Add mobile class if on mobile device
        if (window.innerWidth <= 768) {
          modal.classList.add('mobile-modal');
        }

        modal.style.display = 'flex';

        // Animate in
        setTimeout(() => {
          modal.classList.add('active');
          const input = document.getElementById('text-input');
          if (input) {
            input.focus();

            // Clear any existing text
            input.value = '';

            // Reset text size value display
            const sizeSlider = document.getElementById('text-size');
            const sizeValue = document.getElementById('text-size-value');
            if (sizeSlider && sizeValue) {
              sizeValue.textContent = sizeSlider.value + 'px';
            }

            // Initialize preview state (this will disable the button initially)
            this.updateTextPreview();

            // Add event listeners if they don't exist
            this.setupTextInputListeners();
          }
        }, 10);

        // Ensure modal appears within lightbox
        const lightbox = document.getElementById('designer-lightbox');
        if (lightbox && modal.parentElement !== lightbox.querySelector('.designer-modal')) {
          // Move modal inside lightbox if it's not already there
          lightbox.querySelector('.designer-modal').appendChild(modal);
        }
      }
  }

  setupTextInputListeners() {
      const textInput = document.getElementById('text-input');
      if (textInput && !textInput.hasAttribute('data-listeners-added')) {
        console.log('Setting up text input listeners');

        textInput.addEventListener('input', () => {
          console.log('Text input changed:', textInput.value);
          this.updateTextPreview();
        });

        textInput.addEventListener('paste', () => {
          setTimeout(() => this.updateTextPreview(), 10);
        });

        // Mark as having listeners to avoid duplicates
        textInput.setAttribute('data-listeners-added', 'true');
      }
  }

  hideTextEditor() {
      const modal = document.getElementById('text-editor-modal');
      const input = document.getElementById('text-input');

      if (modal) {
        modal.classList.remove('active');
        modal.classList.remove('mobile-modal');

        // Animate out and then hide
        setTimeout(() => {
          modal.style.display = 'none';
        }, 300); // Wait for animation to complete
      }

      // Clear form values
      if (input) input.value = '';
      const colorInput = document.getElementById('text-color');
      const sizeInput = document.getElementById('text-size');
      const fontSelect = document.getElementById('font-select');

      if (colorInput) colorInput.value = '#000000';
      if (sizeInput) sizeInput.value = '30';
      if (fontSelect) fontSelect.value = 'Arial';

      // Update size display
      const sizeValue = document.getElementById('text-size-value');
      if (sizeValue) sizeValue.textContent = '30px';
  }

  updateTextPreview() {
    const textInput = document.getElementById('text-input');
    const addButton = document.getElementById('add-text-confirm');

    if (textInput && addButton) {
      const hasText = textInput.value.trim().length > 0;
      addButton.disabled = !hasText;

      if (!hasText) {
        addButton.classList.add('disabled');
      } else {
        addButton.classList.remove('disabled');
      }
    }
  }

  addText() {
      console.log('=== ADD TEXT CALLED ===');

      if (!this.canvas) {
        console.error('Canvas not available');
        this.showNotification('Designer not ready. Please try again.', 'error');
        return;
      }

      const text = document.getElementById('text-input')?.value;
      console.log('Text to add:', text);

      if (!text || text.trim().length === 0) {
        this.showNotification('Please enter some text', 'error');
        return;
      }

      const font = document.getElementById('font-select')?.value || 'Arial';
      const color = document.getElementById('text-color')?.value || '#000000';
      const size = parseInt(document.getElementById('text-size')?.value || '30');

      console.log('Text properties:', { text: text.trim(), font, color, size });

      const textPathType = document.querySelector('.text-path-type')?.value || 'none';
      if (textPathType && textPathType !== 'none') {
          this.showNotification('Curved text is a planned feature. Adding regular text for now.');
      }

      try {
        const fabricText = new fabric.Text(text.trim(), {
          fontFamily: font,
          fontSize: size,
          fill: color,
          left: this.clipBounds ? this.clipBounds.left + this.clipBounds.width / 2 : this.canvas.width / 2,
          top: this.clipBounds ? this.clipBounds.top + this.clipBounds.height / 2 : this.canvas.height / 2,
          originX: 'center',
          originY: 'center',
          angle: 0
        });

        console.log('Fabric text object created:', fabricText);

        this.canvas.add(fabricText);
        this.canvas.setActiveObject(fabricText);
        this.ensureProperLayering();
        this.canvas.renderAll();

        console.log('Text added to canvas successfully');

        this.hideTextEditor();
        this.showNotification('Text added successfully!');
        this.analytics.track('add_text', { length: text.length, font, size });

      } catch (error) {
        console.error('Error creating text:', error);
        this.showNotification('Error adding text. Please try again.', 'error');
      }
  }

  setupProductVariantSelector() {
      const variants = this.config.variants || [];

      if (variants.length === 0) {
        console.log('No variants available for selector');
        return;
      }

      const selector = document.createElement('div');
      selector.className = 'product-variant-selector';
      selector.innerHTML = `
        <label>Preview on:</label>
        <select class="variant-preview-select">
          ${variants.map(v => `
            <option value="${v.id}" ${v.id == this.currentVariantId ? 'selected' : ''}>
              ${v.title}
            </option>
          `).join('')}
        </select>
      `;

      const header = document.querySelector('.designer-header');
      if (header) {
        const closeBtn = header.querySelector('.designer-close');
        if (closeBtn) {
          // Only insert if close button exists and is a child of header
          try {
            header.insertBefore(selector, closeBtn);
          } catch (error) {
            console.warn('Could not insert variant selector before close button, appending instead:', error);
            header.appendChild(selector);
          }
        } else {
          // If no close button found, just append to header
          header.appendChild(selector);
        }
      } else {
        console.warn('Designer header not found, cannot add variant selector');
        return;
      }

      const selectElement = selector.querySelector('.variant-preview-select');
      if (selectElement) {
        selectElement.addEventListener('change', (e) => {
          const variantId = e.target.value;
          this.saveSessionDesign();
          this.loadVariantData(variantId);
          this.showNotification('Switching product preview...');
          this.analytics.track('switch_variant', { variantId });
        });
      }
  }

  loadQuantityInfo() {
      console.log('=== LOADING QUANTITY AND PRICING INFO ===');

      // Get quantity from the form
      const quantityInput = document.querySelector('input[name="quantity"]');
      let quantity = 1;
      if (quantityInput && !isNaN(parseInt(quantityInput.value))) {
        quantity = parseInt(quantityInput.value);
      }
      console.log('Quantity found:', quantity);

      // Get price from the product page - multiple selectors to cover different themes
      let unitPrice = 0;
      let priceElement = null;

      // Try different price selectors
      const priceSelectors = [
        '.price ins .woocommerce-Price-amount bdi',
        '.price > .woocommerce-Price-amount bdi',
        '.price .amount bdi',
        '.summary .price bdi',
        '.product-info .price bdi',
        '.price-wrapper .price bdi',
        '.woocommerce-Price-amount bdi'
      ];

      for (const selector of priceSelectors) {
        priceElement = document.querySelector(selector);
        if (priceElement) {
          console.log('Price element found with selector:', selector);
          console.log('Price element HTML:', priceElement.innerHTML);
          break;
        }
      }

      if (priceElement) {
        // Clone the element to manipulate without affecting the DOM
        const clonedElement = priceElement.cloneNode(true);

        // Remove currency symbol if it's a separate element
        const currencySymbol = clonedElement.querySelector('.woocommerce-Price-currencySymbol');
        if (currencySymbol) {
          currencySymbol.remove();
        }

        // Get the text content and extract the number
        const priceText = clonedElement.textContent.trim();
        console.log('Extracted price text:', priceText);

        // Remove all non-numeric characters except dots and commas
        const cleanedPrice = priceText.replace(/[^\d.,]/g, '');
        console.log('Cleaned price:', cleanedPrice);

        // Handle different decimal separators (some locales use comma)
        const normalizedPrice = cleanedPrice.replace(',', '.');
        unitPrice = parseFloat(normalizedPrice) || 0;

        console.log('Final unit price:', unitPrice);
      } else {
        console.warn('No price element found on page');
      }

      // Fallback: try to get price from product meta
      if (unitPrice === 0) {
        const productMeta = document.querySelector('meta[property="product:price:amount"]');
        if (productMeta) {
          unitPrice = parseFloat(productMeta.getAttribute('content')) || 0;
          console.log('Price from meta tag:', unitPrice);
        }
      }

      this.quantityInfo = {
        quantity: quantity,
        unitPrice: unitPrice,
        totalPrice: quantity * unitPrice
      };
  }

  applyCrop() {
    if (!this.cropper || !this.croppingObject || !this.canvas) return;

    const croppedDataURL = this.cropper.getCroppedCanvas().toDataURL();

    fabric.Image.fromURL(croppedDataURL, (img) => {
      img.set({
        left: this.croppingObject.left,
        top: this.croppingObject.top,
        angle: this.croppingObject.angle,
        opacity: this.croppingObject.opacity,
        scaleX: this.croppingObject.scaleX,
        scaleY: this.croppingObject.scaleY,
        originX: this.croppingObject.originX,
        originY: this.croppingObject.originY,
        filters: this.croppingObject.filters
      });
      img.applyFilters();

      this.canvas.remove(this.croppingObject);
      this.canvas.add(img);
      this.canvas.setActiveObject(img);
      this.ensureProperLayering();
      this.canvas.renderAll();
      this.saveHistory();
      this.cleanupCrop();
    }, { crossOrigin: 'anonymous' });
  }

  cancelCrop() {
    if (this.croppingObject && this.canvas) {
      this.croppingObject.visible = true;
      this.canvas.renderAll();
    }
    this.cleanupCrop();
  }

  cleanupCrop() {
    if (this.cropper) {
      this.cropper.destroy();
      this.cropper = null;
    }
    document.getElementById('crop-container')?.remove();
    this.isCropping = false;
    this.croppingObject = null;
    document.getElementById('crop-btn').style.display = 'flex';
    document.getElementById('crop-controls').style.display = 'none';
  }

  startCrop() {
    if (!this.canvas) return;
    const activeObject = this.canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image' || activeObject.selectable === false) {
      this.showNotification('Please select an image to crop');
      return;
    }
    this.isCropping = true;
    this.croppingObject = activeObject;
    activeObject.visible = false;
    this.canvas.renderAll();

    const cropContainer = document.createElement('div');
    cropContainer.id = 'crop-container';
    const canvasOffset = this.canvas.getElement().getBoundingClientRect();
    cropContainer.style.position = 'absolute';
    cropContainer.style.top = `${canvasOffset.top}px`;
    cropContainer.style.left = `${canvasOffset.left}px`;
    cropContainer.style.width = `${canvasOffset.width}px`;
    cropContainer.style.height = `${canvasOffset.height}px`;
    cropContainer.style.overflow = 'hidden';
    cropContainer.style.zIndex = '999';

    const img = document.createElement('img');
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'contain';
    img.src = activeObject.getSrc();
    cropContainer.appendChild(img);
    document.body.appendChild(cropContainer);

    this.cropper = new Cropper(img, {
      aspectRatio: NaN,
      viewMode: 1,
      background: false,
      autoCropArea: 0.8,
      responsive: true,
      ready: () => {
        const objRect = activeObject.getBoundingRect(true);
        const scaleFactorX = img.naturalWidth / this.canvas.width;
        const scaleFactorY = img.naturalHeight / this.canvas.height;

        this.cropper.setCropBoxData({
          left: objRect.left * scaleFactorX,
          top: objRect.top * scaleFactorY,
          width: objRect.width * scaleFactorX,
          height: objRect.height * scaleFactorY
        });
      }
    });

    document.getElementById('crop-btn').style.display = 'none';
    document.getElementById('crop-controls').style.display = 'block';
  }

  saveDesign() {
    if (!this.canvas) return;
    const designNameModal = document.createElement('div');
    designNameModal.className = 'text-editor-modal';
    designNameModal.innerHTML = `
      <div class="modal-content">
        <h3>Save Design</h3>
        <input type="text" id="design-name-input" placeholder="Enter a name for your design" />
        <div class="modal-actions">
          <button class="btn btn-secondary" id="cancel-save-design">Cancel</button>
          <button class="btn btn-primary" id="confirm-save-design">Save</button>
        </div>
      </div>
    `;
    document.body.appendChild(designNameModal);
    designNameModal.style.display = 'flex';

    const nameInput = document.getElementById('design-name-input');
    const confirmBtn = document.getElementById('confirm-save-design');
    const cancelBtn = document.getElementById('cancel-save-design');

    nameInput?.focus();

    const handleSave = () => {
      const designName = nameInput?.value.trim();
      if (!designName) {
        this.showNotification('Please enter a name for your design.', 'error');
        return;
      }

      const userObjects = this.canvas.getObjects().filter(obj => obj.selectable !== false);
      const designData = {
        name: designName,
        date: new Date().toISOString(),
        canvasData: { objects: userObjects.map(obj => obj.toObject(['selectable', 'evented', 'crossOrigin'])) },
        variantId: this.currentVariantId,
        preview: this.canvas.toDataURL()
      };

      this.savedDesigns.push(designData);
      this.saveSavedDesigns();
      document.body.removeChild(designNameModal);
      this.showNotification("Design saved successfully!");
    };

    confirmBtn?.addEventListener("click", handleSave);
    cancelBtn?.addEventListener("click", () => {
      document.body.removeChild(designNameModal);
    });

    nameInput?.addEventListener("keypress", (e) => {
      if (e.key === "Enter") handleSave();
    });
  }

  loadVariantData(variantId) {
    this.currentVariantId = variantId;
    const variants = swpdDesignerConfig.variants;
    if (!variants || !Array.isArray(variants)) {
      console.error('No variants data available in swpdDesignerConfig.');
      this.hideLoading();
      return;
    }

    const variant = variants.find(v => v && v.id == variantId);
    if (!variant) {
      console.error(`Variant with ID ${variantId} not found in available variants.`);
      this.showNotification('This product variant is not configured for customization.');
      this.hideLoading();
      return;
    }

    let designerData = variant.designer_data;
    if (!designerData) {
      console.error('No designer data found for variant. Please ensure the variant has _design_tool_layer metafield configured.');
      this.showNotification('This product variant is not configured for customization.');
      this.hideLoading();
      return;
    }

    if (typeof designerData === 'string') {
      try {
        designerData = JSON.parse(designerData);
      } catch(e) {
        console.error('Failed to parse designer data string:', e);
        this.showNotification('Error loading designer configuration. Please contact support.');
        this.hideLoading();
        return;
      }
    }

    if (designerData.baseImage && designerData.alphaMask) {
      this.loadDesign(designerData);
    } else {
      console.error('Invalid designer data structure. Expected baseImage and alphaMask properties:', designerData);
      this.showNotification('Designer configuration is incomplete. Please contact support.');
      this.hideLoading();
      return;
    }
  }

  loadDesign(data) {
    console.log('Loading design with data:', data);

    // Store URLs for later use
    this.backgroundUrl = data.baseImage;
    this.maskUrl = data.alphaMask;

    const loadImages = () => {
        if (!this.canvas) {
            setTimeout(loadImages, 100);
            return;
        }

        this.canvas.clear();
        this.canvas.backgroundColor = '#f5f5f5';
        this.isLoadingDesign = true;

        // Load only base image and alpha mask
        Promise.all([
            this.loadImagePromise(data.baseImage),
            this.loadImagePromise(data.alphaMask)
        ]).then(([bgImg, alphaMaskImg]) => {
            console.log('Images loaded successfully');

            this.backgroundImage = bgImg;
            this.maskImage = alphaMaskImg;

            const canvasWidth = this.canvas.width;
            const canvasHeight = this.canvas.height;

            // Scale and position images
            const fitScale = (img) => {
                const scaleX = canvasWidth / img.width;
                const scaleY = canvasHeight / img.height;
                return Math.min(scaleX, scaleY);
            }

            const bgScale = fitScale(bgImg);
            bgImg.set({
                scaleX: bgScale,
                scaleY: bgScale,
                left: canvasWidth / 2,
                top: canvasHeight / 2,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false
            });

            const maskScale = fitScale(alphaMaskImg);
            alphaMaskImg.set({
              scaleX: maskScale,
              scaleY: maskScale,
              left: canvasWidth / 2,
              top: canvasHeight / 2,
              originX: 'center',
              originY: 'center',
              selectable: false,
              evented: false,
              opacity: 1 // Full opacity
            });

            this.canvas.add(bgImg);
            this.canvas.add(alphaMaskImg);

            // Setup mask clipping (just for bounds calculation)
            this.setupMaskClipping();

            // Check for preserved data or session
            if (this.preservedCanvasData) {
              this.loadPreservedDesign();
            } else {
              const sessionLoaded = this.loadSessionDesign();
              if (!sessionLoaded) {
                setTimeout(() => {
                  this.isLoadingDesign = false;
                  this.saveHistory();
                }, 100);
              }
            }

            this.hideLoading();
        }).catch(error => {
            console.error('Error loading images:', error);
            this.isLoadingDesign = false;
            this.hideLoading();
            this.showNotification('Error loading product images. Please try again.', 'error');
        });
    };

    loadImages();
  }

  updateUIAfterDesign() {
      // Add body class to show the add to cart button
      document.body.classList.add('swpd-design-applied');

      const customizeBtn = document.getElementById('swpd-customize-design-button');
      if (customizeBtn) {
          customizeBtn.style.display = 'inline-flex';
          customizeBtn.innerHTML = `
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                  <path d="M12 20h9M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"/>
              </svg>
              ${(typeof swpdTranslations !== 'undefined' && swpdTranslations.editDesign) ? swpdTranslations.editDesign : 'Edit Design'}
          `;
      }

      const productForm = document.querySelector('form.cart');
      if (productForm) {
          const addToCartBtn = productForm.querySelector('button[name="add-to-cart"], button[type="submit"]:not(#swpd-customize-design-button)');
          if (addToCartBtn) {
              addToCartBtn.style.display = 'inline-block'; // Show the original button
              addToCartBtn.textContent = (typeof swpdTranslations !== 'undefined' && swpdTranslations.addToCart) ? swpdTranslations.addToCart : 'Add to Cart';
          }
      }
  }

  loadDesignFromCartData(productUrl, variantId, canvasData) {
    sessionStorage.setItem('edit_design_data', canvasData);
    sessionStorage.setItem('edit_design_variant', variantId);
    window.location.href = `${productUrl}?edit_design=1&variant=${variantId}`;
  }

  setupEventListeners() {
    const setupListeners = () => {
      const closeBtn = document.querySelector('.designer-close');
      if (!closeBtn) {
        setTimeout(setupListeners, 100);
        return;
      }

      closeBtn.addEventListener('click', () => this.closeLightbox());
      document.querySelector('.cancel-design')?.addEventListener('click', () => this.closeLightbox());
      document.querySelector('.apply-design')?.addEventListener('click', () => this.applyDesign());
      document.querySelector('.add-to-cart-design')?.addEventListener('click', () => this.addToCart());

      document.getElementById('undo-btn')?.addEventListener('click', () => this.undo());
      document.getElementById('redo-btn')?.addEventListener('click', () => this.redo());

      document.querySelectorAll('.image-upload-input').forEach(input => {
        input.addEventListener('change', (e) => this.handleImageUpload(e));
      });

      // Simplified upload button setup
      document.querySelectorAll('.image-upload-input').forEach((input, index) => {
        console.log(`Setting up file input ${index + 1} with ID:`, input.id);
        input.addEventListener('change', (e) => {
          console.log(`File input ${index + 1} changed, files:`, e.target.files.length);
          this.handleImageUpload(e);
        });
      });

      // Additional setup for main file input
      const mainFileInput = document.getElementById('main-file-input');
      if (mainFileInput) {
        console.log('Main file input found and set up');
        mainFileInput.addEventListener('change', (e) => {
          console.log('Main file input changed, files:', e.target.files.length);
          this.handleImageUpload(e);
        });
      } else {
        console.warn('Main file input not found');
      }

      // Debug upload button
      const uploadBtn = document.querySelector('.upload-image-btn');
      if (uploadBtn) {
        console.log('Upload button found');
        uploadBtn.addEventListener('click', function() {
          console.log('Upload button clicked');
        });
      } else {
        console.warn('Upload button not found');
      }

      document.querySelector('.add-text-btn')?.addEventListener('click', () => this.showTextEditor());
      document.getElementById('add-text-confirm')?.addEventListener('click', () => this.addText());
      document.getElementById('cancel-text')?.addEventListener('click', () => this.hideTextEditor());
      document.querySelector('.modal-close')?.addEventListener('click', () => this.hideTextEditor());

      document.getElementById('text-size')?.addEventListener('input', (e) => {
        const sizeValue = document.getElementById('text-size-value');
        if (sizeValue) sizeValue.textContent = e.target.value + 'px';
      });

      // Add event listener for text input to enable/disable the add button
      document.getElementById('text-input')?.addEventListener('input', () => {
        this.updateTextPreview();
      });

      // Also listen for paste events
      document.getElementById('text-input')?.addEventListener('paste', () => {
        setTimeout(() => this.updateTextPreview(), 10);
      });

      document.getElementById('crop-btn')?.addEventListener('click', () => this.startCrop());
      document.querySelector('.apply-crop-btn')?.addEventListener('click', () => this.applyCrop());
      document.querySelector('.cancel-crop-btn')?.addEventListener('click', () => this.cancelCrop());

      document.querySelector('.save-design-btn')?.addEventListener('click', () => this.saveDesign());
      document.querySelector('.load-design-btn')?.addEventListener('click', () => this.showSavedDesigns());

      // Add help button listener
      document.querySelector('.help-btn')?.addEventListener('click', () => this.showHelp());

      const setupCanvasListeners = () => {
        if (this.canvas) {
          this.canvas.on('selection:created', (e) => {
            this.showProperties(e.selected[0]);
            const cropBtn = document.getElementById('crop-btn');
            const editTools = document.getElementById('edit-tools');
            if (cropBtn && e.selected[0].type === 'image' && e.selected[0].selectable !== false) {
              cropBtn.style.display = 'flex';
              if (editTools) editTools.style.display = 'block';
            }
          });
          this.canvas.on('selection:updated', (e) => {
            this.showProperties(e.selected[0]);
            const cropBtn = document.getElementById('crop-btn');
            const editTools = document.getElementById('edit-tools');
            if (cropBtn) {
              cropBtn.style.display = (e.selected[0].type === 'image' && e.selected[0].selectable !== false) ? 'flex' : 'none';
              if (editTools) editTools.style.display = (e.selected[0].type === 'image' && e.selected[0].selectable !== false) ? 'block' : 'none';
            }
          });
          this.canvas.on('selection:cleared', () => {
            this.hideProperties();
            const cropBtn = document.getElementById('crop-btn');
            const editTools = document.getElementById('edit-tools');
            if (cropBtn) cropBtn.style.display = 'none';
            if (editTools) editTools.style.display = 'none';
            if (this.isCropping) {
              this.cancelCrop();
            }
            const propsPanel = document.querySelector('.properties-panel');
            if (propsPanel && window.innerWidth <= 768) {
              propsPanel.classList.remove('mobile-visible');
            }
          });
          this.canvas.on('object:scaling', (e) => {
            if (e.target.type === 'image' && e.target.selectable !== false) {
              this.checkImageResolution(e.target._element, e.target);
            }
          });
          this.canvas.on('object:moved', (e) => {
            if (e.target.type === 'image' && e.target.selectable !== false) {
              this.checkImageResolution(e.target._element, e.target);
            }
          });
          this.canvas.on('object:modified', () => {
            if (!this.isReordering && !this.isLoadingDesign) {
              this.saveHistory();
            }
          });
          this.canvas.on('object:added', (e) => {
            if (!this.isRedoing && !this.isReordering && !this.isLoadingDesign && e.target && e.target.selectable !== false) {
              this.saveHistory();
              this.ensureProperLayering();
            }
          });
          this.canvas.on('object:removed', (e) => {
            if (!this.isReordering && !this.isLoadingDesign && e.target && e.target.selectable !== false) {
              this.saveHistory();
            }
          });
          this.canvas.on('path:created', (e) => {
            if (e.path) {
              this.canvas.remove(e.path);
            }
          });
          this.canvas.on('mouse:down', () => {
            if (this.canvas.isDrawingMode) {
              this.canvas.isDrawingMode = false;
            }
          });
        } else {
          setTimeout(setupCanvasListeners, 100);
        }
      };
      setupCanvasListeners();
    };
    setupListeners();
  }

  setupLayersPanel() {
    const layersPanel = document.createElement('div');
    layersPanel.className = 'layers-panel';
    layersPanel.innerHTML = `
      <h3>Layers</h3>
      <div class="layers-list" id="layers-list"></div>
    `;

    const propertiesPanel = document.querySelector('.properties-panel');
    if (propertiesPanel) {
      propertiesPanel.appendChild(layersPanel);
    }

    if (this.canvas) {
      this.canvas.on('object:added', () => this.updateLayersPanel());
      this.canvas.on('object:removed', () => this.updateLayersPanel());
      this.canvas.on('object:modified', () => this.updateLayersPanel());
    }
  }

  updateLayersPanel() {
    const layersList = document.getElementById('layers-list');
    if (!layersList || !this.canvas) return;

    layersList.innerHTML = '';
    const objects = this.canvas.getObjects().filter(obj => obj.selectable !== false);

    objects.reverse().forEach((obj, index) => {
      const layerItem = document.createElement('div');
      layerItem.className = 'layer-item';
      layerItem.dataset.index = objects.length - 1 - index;

      const isSelected = this.canvas.getActiveObjects().includes(obj);
      if (isSelected) layerItem.classList.add('selected');

      layerItem.innerHTML = `
        <div class="layer-controls">
          <button class="layer-visibility" title="Toggle visibility">
            <svg width="16" height="16" viewBox="0 0 24 24">
              <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
            </svg>
          </button>
          <button class="layer-lock" title="Toggle lock">
            <svg width="16" height="16" viewBox="0 0 24 24">
              <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>
            </svg>
          </button>
        </div>
        <span class="layer-name">${obj.type === 'text' ? obj.text : obj.type}</span>
        <div class="layer-reorder">
          <button class="layer-up" title="Move up"></button>
          <button class="layer-down" title="Move down"></button>
        </div>
      `;

      layerItem.addEventListener('click', (e) => {
        if (!e.target.closest('button')) {
          this.canvas.setActiveObject(obj);
          this.canvas.renderAll();
          this.updateLayersPanel();
        }
      });

      layerItem.querySelector('.layer-visibility').addEventListener('click', () => {
        obj.visible = !obj.visible;
        this.canvas.renderAll();
        layerItem.classList.toggle('hidden');
      });

      layerItem.querySelector('.layer-lock').addEventListener('click', () => {
        obj.selectable = !obj.selectable;
        obj.evented = !obj.evented;
        layerItem.classList.toggle('locked');
      });

      layerItem.querySelector('.layer-up').addEventListener('click', () => {
        const currentIndex = objects.length - 1 - index;
        if (currentIndex < objects.length - 1) {
          obj.bringForward();
          this.updateLayersPanel();
        }
      });

      layerItem.querySelector('.layer-down').addEventListener('click', () => {
        const currentIndex = objects.length - 1 - index;
        if (currentIndex > 0) {
          obj.sendBackwards();
          this.updateLayersPanel();
        }
      });

      layersList.appendChild(layerItem);
    });
  }

  setupAlignmentTools() {
    const alignmentPanel = document.createElement('div');
    alignmentPanel.className = 'alignment-tools';
    alignmentPanel.style.display = 'none';
    alignmentPanel.innerHTML = `
      <h4>Alignment</h4>
      <div class="alignment-buttons">
        <button class="align-btn" data-align="left" title="Align left">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 4v16h2V4H4zm4 12h12v-2H8v2zm0-6h12V8H8v2z"/></svg>
        </button>
        <button class="align-btn" data-align="center-h" title="Align center horizontally">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M11 4v5H6v2h5v2H8v2h3v5h2v-5h3v-2h-3v-2h5V9h-5V4h-2z"/></svg>
        </button>
        <button class="align-btn" data-align="right" title="Align right">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M18 4v16h2V4h-2zM4 16h12v-2H4v2zm0-6h12V8H4v2z"/></svg>
        </button>
        <button class="align-btn" data-align="top" title="Align top">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 4h16v2H4V4zm12 4v12h-2V8h2zm-6 0v12H8V8h2z"/></svg>
        </button>
        <button class="align-btn" data-align="center-v" title="Align center vertically">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 11h5V6h2v5h2V8h2v3h5v2h-5v3h-2v-3h-2v5H9v-5H4v-2z"/></svg>
        </button>
        <button class="align-btn" data-align="bottom" title="Align bottom">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 18h16v2H4v-2zm12-14v12h-2V4h2zm-6 0v12H8V4h2z"/></svg>
        </button>
      </div>
      <h4>Distribution</h4>
      <div class="distribution-buttons">
        <button class="distribute-btn" data-distribute="h" title="Distribute horizontally">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 4v16h2V4H4zm14 0v16h2V4h-2zm-6 4v8h2V8h-2z"/></svg>
        </button>
        <button class="distribute-btn" data-distribute="v" title="Distribute vertically">
          <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 4h16v2H4V4zm0 14h16v2H4v-2zm4-6h8v2H8v-2z"/></svg>
        </button>
      </div>
    `;

    const propertiesPanel = document.querySelector('.properties-panel');
    if (propertiesPanel) {
      propertiesPanel.appendChild(alignmentPanel);
    }

    alignmentPanel.querySelectorAll('.align-btn').forEach(btn => {
      btn.addEventListener('click', () => this.alignObjects(btn.dataset.align));
    });

    alignmentPanel.querySelectorAll('.distribute-btn').forEach(btn => {
      btn.addEventListener('click', () => this.distributeObjects(btn.dataset.distribute));
    });

    if (this.canvas) {
      this.canvas.on('selection:created', () => this.updateAlignmentTools());
      this.canvas.on('selection:updated', () => this.updateAlignmentTools());
      this.canvas.on('selection:cleared', () => this.updateAlignmentTools());
    }
  }

  updateAlignmentTools() {
    const alignmentTools = document.querySelector('.alignment-tools');
    if (!alignmentTools) return;

    const activeObjects = this.canvas.getActiveObjects();
    alignmentTools.style.display = activeObjects.length > 1 && !activeObjects.some(obj => obj === this.backgroundImage || obj === this.maskImage || obj === this.unclippedMaskImage) ? 'block' : 'none';
  }

  alignObjects(alignment) {
    const activeObjects = this.canvas.getActiveObjects().filter(obj => obj.selectable !== false);
    if (activeObjects.length < 2) return;

    const group = new fabric.ActiveSelection(activeObjects, { canvas: this.canvas });
    const groupBounds = group.getBoundingRect();
    this.canvas.discardActiveObject();

    activeObjects.forEach(obj => {
      switch(alignment) {
        case 'left':
          obj.set('left', groupBounds.left + (obj.width * obj.scaleX / 2));
          break;
        case 'center-h':
          obj.set('left', groupBounds.left + (groupBounds.width / 2));
          break;
        case 'right':
          obj.set('left', groupBounds.left + groupBounds.width - (obj.width * obj.scaleX / 2));
          break;
        case 'top':
          obj.set('top', groupBounds.top + (obj.height * obj.scaleY / 2));
          break;
        case 'center-v':
          obj.set('top', groupBounds.top + (groupBounds.height / 2));
          break;
        case 'bottom':
          obj.set('top', groupBounds.top + groupBounds.height - (obj.height * obj.scaleY / 2));
          break;
      }
      obj.setCoords();
    });

    this.canvas.setActiveObject(new fabric.ActiveSelection(activeObjects, { canvas: this.canvas }));
    this.canvas.renderAll();
    this.saveHistory();
    this.analytics.track('align_objects', { alignment, count: activeObjects.length });
  }

  distributeObjects(direction) {
    const activeObjects = this.canvas.getActiveObjects().filter(obj => obj.selectable !== false);
    if (activeObjects.length < 3) return;

    if (direction === 'h') {
      activeObjects.sort((a, b) => a.left - b.left);
      const minX = activeObjects[0].left;
      const maxX = activeObjects[activeObjects.length - 1].left;
      const totalSpace = maxX - minX;
      const spacing = totalSpace / (activeObjects.length - 1);

      activeObjects.forEach((obj, index) => {
        obj.set('left', minX + spacing * index);
        obj.setCoords();
      });
    } else {
      activeObjects.sort((a, b) => a.top - b.top);
      const minY = activeObjects[0].top;
      const maxY = activeObjects[activeObjects.length - 1].top;
      const totalSpace = maxY - minY;
      const spacing = totalSpace / (activeObjects.length - 1);

      activeObjects.forEach((obj, index) => {
        obj.set('top', minY + spacing * index);
        obj.setCoords();
      });
    }

    this.canvas.setActiveObject(new fabric.ActiveSelection(activeObjects, { canvas: this.canvas }));
    this.canvas.renderAll();
    this.saveHistory();
    this.analytics.track('distribute_objects', { direction, count: activeObjects.length });
  }

  setupCanvasControls() {
    if (!this.canvas) return;

    // Custom controls for fabric objects
    fabric.Object.prototype.set({
      transparentCorners: false,
      cornerColor: '#ff4444',
      cornerStrokeColor: '#fff',
      borderColor: '#0073aa',
      cornerSize: window.innerWidth <= 768 ? 16 : 12,
      cornerStyle: 'circle',
      borderScaleFactor: 2,
      borderDashArray: [5, 5],
      rotatingPointOffset: 40
    });

    // Delete control icon
    const deleteIcon = "data:image/svg+xml,%3Csvg height='20' width='20' viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M128 405.429C128 428.846 147.198 448 170.667 448h170.667C364.802 448 384 428.846 384 405.429V160H128v245.429zM416 96h-80l-26.785-32H202.786L176 96H96v32h320V96z' fill='%23ffffff'/%3E%3C/svg%3E";

    const deleteImg = document.createElement('img');
    deleteImg.src = deleteIcon;

    // Custom delete control
    fabric.Object.prototype.controls.deleteControl = new fabric.Control({
      x: 0.5,
      y: -0.5,
      offsetY: -20,
      offsetX: 20,
      cursorStyle: 'pointer',
      mouseUpHandler: (eventData, transform) => {
        const target = transform.target;
        const canvas = target.canvas;

        // Show confirmation on mobile
        if (window.innerWidth <= 768) {
          if (confirm('Delete this item?')) {
            canvas.remove(target);
            canvas.requestRenderAll();
          }
        } else {
          canvas.remove(target);
          canvas.requestRenderAll();
        }

        this.saveHistory();
        this.showNotification('Item deleted');
        return true;
      },
      render: function(ctx, left, top, styleOverride, fabricObject) {
        const size = 24;
        ctx.save();
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        ctx.arc(left, top, size/2, 0, 2 * Math.PI);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (deleteImg.complete) {
          ctx.drawImage(deleteImg, left - size/2 + 2, top - size/2 + 2, size - 4, size - 4);
        }

        ctx.restore();
      },
      cornerSize: 24
    });

    // Enhanced rotation control
    const rotateIcon = "data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z' fill='%23ffffff'/%3E%3C/svg%3E";

    fabric.Object.prototype.controls.mtr = new fabric.Control({
      x: 0,
      y: -0.5,
      offsetY: -40,
      cursorStyle: 'crosshair',
      actionHandler: fabric.controlsUtils.rotationWithSnapping,
      actionName: 'rotate',
      render: function(ctx, left, top, styleOverride, fabricObject) {
        const size = 24;
        ctx.save();
        ctx.fillStyle = '#0073aa';
        ctx.beginPath();
        ctx.arc(left, top, size/2, 0, 2 * Math.PI);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw rotation icon
        const rotateImg = new Image();
        rotateImg.src = rotateIcon;
        if (rotateImg.complete) {
          ctx.drawImage(rotateImg, left - size/2 + 2, top - size/2 + 2, size - 4, size - 4);
        }

        ctx.restore();
      },
      cornerSize: 24,
      withConnection: true
    });

    // Add opacity slider on selection
    this.canvas.on('selection:created', (e) => this.showInlineControls(e.selected[0]));
    this.canvas.on('selection:updated', (e) => this.showInlineControls(e.selected[0]));
    this.canvas.on('selection:cleared', () => this.hideInlineControls());
  }

  showInlineControls(object) {
    if (!object || object === this.backgroundImage || object === this.maskImage || object === this.unclippedMaskImage) return;

    this.hideInlineControls();

    const controlsDiv = document.createElement('div');
    controlsDiv.id = 'inline-controls';
    controlsDiv.className = 'inline-controls';
    controlsDiv.innerHTML = `
      <div class="inline-control-item">
        <label>Opacity:</label>
        <input type="range" class="inline-opacity" min="0" max="100" value="${object.opacity * 100}">
        <span class="inline-value">${Math.round(object.opacity * 100)}%</span>
      </div>
      ${object.type === 'image' ? `
        <div class="inline-control-item">
          <button class="btn btn-sm btn-danger" id="inline-delete">
            <svg width="16" height="16" viewBox="0 0 24 24">
              <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" fill="currentColor"/>
            </svg>
            Delete
          </button>
        </div>
      ` : ''}
    `;

    const canvasContainer = document.querySelector('.canvas-container');
    if (canvasContainer) {
      canvasContainer.appendChild(controlsDiv);

      const opacitySlider = controlsDiv.querySelector('.inline-opacity');
      const opacityValue = controlsDiv.querySelector('.inline-value');

      opacitySlider.addEventListener('input', (e) => {
        object.set('opacity', e.target.value / 100);
        opacityValue.textContent = e.target.value + '%';
        this.canvas.renderAll();
      });

      // Add delete button functionality
      const deleteBtn = controlsDiv.querySelector('#inline-delete');
      if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
          if (window.innerWidth <= 768 && !confirm('Delete this image?')) {
            return;
          }
          this.canvas.remove(object);
          this.canvas.renderAll();
          this.hideInlineControls();
          this.saveHistory();
          this.showNotification('Image deleted');
        });
      }
    }
  }

  hideInlineControls() {
    const controls = document.getElementById('inline-controls');
    if (controls) controls.remove();
  }

  adjustLayoutForDesktop() {
    if (window.innerWidth > 768) {
      const propsPanel = document.querySelector('.properties-panel');
      const canvasContainer = document.querySelector('.canvas-container');

      if (propsPanel) {
        propsPanel.style.display = 'none';
      }

      // Adjust canvas container to take full width without properties panel
      if (canvasContainer) {
        canvasContainer.style.marginRight = '20px';
      }
    }
  }

  openLightbox(variantId, preservedData = null) {
    console.log('=== OPENING LIGHTBOX DEBUG ===');
    console.log('Variant ID:', variantId);

    const lightbox = document.getElementById('designer-lightbox');
    console.log('Lightbox element found:', !!lightbox);

    if (!lightbox) {
      console.error('ERROR: Lightbox element with ID "designer-lightbox" not found!');
      console.log('Available elements with "designer" in ID:',
        Array.from(document.querySelectorAll('[id*="designer"]')).map(el => el.id)
      );

      // Try to create a basic lightbox structure as fallback
      console.log('Attempting to create fallback lightbox...');
      this.createFallbackLightbox();

      // Try again to find the lightbox
      const fallbackLightbox = document.getElementById('designer-lightbox');
      if (!fallbackLightbox) {
        this.showNotification('Designer interface could not be loaded. The plugin may not be properly configured.', 'error');
        console.error('CRITICAL: Could not create fallback lightbox. This suggests the plugin PHP code is not running.');
        return;
      }
    }

    const finalLightbox = document.getElementById('designer-lightbox');
    console.log('Setting lightbox display to flex...');
    finalLightbox.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    setTimeout(() => {
      console.log('Adding active class to lightbox...');
      finalLightbox.classList.add('active');
    }, 10);

    if (!preservedData && this.preservedCanvasData) {
      preservedData = this.preservedCanvasData;
    }

    if (preservedData) {
      this.preservedCanvasData = preservedData;
    }

    const currentVariantId = variantId || swpdDesignerConfig.product_id;
    const variants = swpdDesignerConfig.variants;
    if (variants) this.config.variants = variants;

    console.log('Current variant ID:', currentVariantId);
    console.log('Variants available:', variants ? variants.length : 0);

    // Check if we can load variant data
    if (currentVariantId) {
      console.log('Loading variant data...');
      this.loadVariantData(currentVariantId);
    } else {
      console.log('No variant ID, hiding loading...');
      this.hideLoading();
    }

    this.showLoading();
    this.history = [];
    this.historyStep = -1;
    this.updateHistoryButtons();

    this.loadQuantityInfo();

    console.log('Lightbox should now be visible. Checking final state...');
    setTimeout(() => {
      const lightboxAfter = document.getElementById('designer-lightbox');
      if (lightboxAfter) {
        console.log('Lightbox display style:', lightboxAfter.style.display);
        console.log('Lightbox classes:', lightboxAfter.className);
        console.log('Lightbox visible:', lightboxAfter.offsetWidth > 0 && lightboxAfter.offsetHeight > 0);
      }
    }, 100);
    console.log('=== END OPENING LIGHTBOX DEBUG ===');
  }

  openLightboxWithVariant(variantId, variants) {
    this.openLightbox(variantId);
  }

  closeLightbox() {
    const lightbox = document.getElementById('designer-lightbox');
    if (!lightbox) return;
    this.saveSessionDesign();
    this.stopAutoSave();
    lightbox.classList.remove('active');
    setTimeout(() => {
      lightbox.style.display = 'none';
      document.body.style.overflow = '';
      this.canvas.clear();
      this.backgroundImage = null;
      this.maskImage = null;
      this.unclippedMaskImage = null;
      this.history = [];
      this.historyStep = -1;
      this.preservedCanvasData = null;
    }, 300);
    if (this.isCropping) this.cancelCrop();
  }

  showLoading() {
    const loadingEl = document.querySelector('.designer-loading');
    if (loadingEl) {
      loadingEl.style.display = 'flex';
      console.log('Showing loading spinner...');
    }
    const designerBody = document.querySelector('.designer-body');
    if (designerBody) {
      designerBody.style.opacity = '0';
    }
  }

  hideLoading() {
    const loadingEl = document.querySelector('.designer-loading');
    if (loadingEl) {
      loadingEl.style.display = 'none';
      console.log('Hiding loading spinner...');
    }
    const designerBody = document.querySelector('.designer-body');
    if (designerBody) {
      designerBody.style.opacity = '1';
    }
  }

  setupMobileUI() {
        if (window.innerWidth <= 768) {
            // Setup mobile quick actions
            this.setupMobileQuickActions();

            // Setup mobile tools drawer
            this.setupMobileToolsDrawer();

            // Add mobile upload zone when no items
            this.setupMobileUploadZone();

            // Setup touch gestures
            this.setupTouchGestures();

            // Add mobile-specific event handlers
            this.setupMobileEventHandlers();
        }
  }

  setupMobileQuickActions() {
        // Upload button
        const mobileUploadBtn = document.getElementById('mobile-upload-btn');
        if (mobileUploadBtn) {
            const fileInput = mobileUploadBtn.querySelector('input[type="file"]');
            mobileUploadBtn.addEventListener('click', (e) => {
                if (e.target.tagName !== 'INPUT') {
                    fileInput.click();
                }
            });

            fileInput.addEventListener('change', (e) => this.handleImageUpload(e));
        }

        // Text button
        const mobileTextBtn = document.getElementById('mobile-text-btn');
        if (mobileTextBtn) {
            mobileTextBtn.addEventListener('click', () => this.showTextEditor());
        }

        // Templates button
        const mobileTemplatesBtn = document.getElementById('mobile-templates-btn');
        if (mobileTemplatesBtn) {
            mobileTemplatesBtn.addEventListener('click', () => this.showTemplatesModal());
        }

        // Save button
        const mobileSaveBtn = document.getElementById('mobile-save-btn');
        if (mobileSaveBtn) {
            mobileSaveBtn.addEventListener('click', () => this.saveDesign());
        }

        // Apply/Done button
        const mobileApplyBtn = document.getElementById('mobile-apply-btn');
        if (mobileApplyBtn) {
            mobileApplyBtn.addEventListener('click', () => {
                if (this.canvas && this.canvas.getObjects().filter(obj => obj.selectable !== false).length > 0) {
                    this.applyDesign();
                } else {
                    this.showNotification('Please add at least one element to your design', 'warning');
                }
            });
        }
  }

  setupMobileToolsDrawer() {
        const drawer = document.getElementById('mobile-tools-drawer');
        const closeBtn = document.getElementById('mobile-tools-close');

        if (drawer && closeBtn) {
            closeBtn.addEventListener('click', () => {
                drawer.classList.remove('active');
            });

            // Close on outside click
            drawer.addEventListener('click', (e) => {
                if (e.target === drawer) {
                    drawer.classList.remove('active');
                }
            });
        }
  }

  setupMobileUploadZone() {
        if (!this.canvas) return;

        const checkAndShowUploadZone = () => {
            const objects = this.canvas.getObjects().filter(obj => obj.selectable !== false);
            if (objects.length === 0) {
                const uploadZone = document.createElement('div');
                uploadZone.className = 'mobile-upload-zone';
                uploadZone.innerHTML = `
                    <h3>${this.translations?.startDesigning || 'Start Designing'}</h3>
                    <p>${this.translations?.tapToUpload || 'Tap the upload button below to add your first image'}</p>
                    <svg width="60" height="60" viewBox="0 0 24 24" fill="var(--swpd-primary)" opacity="0.5">
                        <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
                    </svg>
                `;

                const canvasContainer = document.querySelector('.canvas-container');
                if (canvasContainer && !canvasContainer.querySelector('.mobile-upload-zone')) {
                    canvasContainer.appendChild(uploadZone);

                    // Animate in
                    setTimeout(() => {
                        uploadZone.style.opacity = '1';
                    }, 100);
                }
            } else {
                // Remove upload zone if items exist
                const existingZone = document.querySelector('.mobile-upload-zone');
                if (existingZone) {
                    existingZone.remove();
                }
            }
        };

        // Listen for canvas changes
        if (this.canvas) {
          this.canvas.on("object:added", checkAndShowUploadZone);
          this.canvas.on("object:removed", checkAndShowUploadZone);
        }

        // Initial check
        checkAndShowUploadZone();
  }

  get_user_identifier() {
      // Generate or retrieve a unique user identifier
      let userId = localStorage.getItem('swpd_user_id');
      if (!userId) {
        userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('swpd_user_id', userId);
      }
      return userId;
  }

  log(message, data = null) {
      if (this.config.debug || (typeof swpdDesignerConfig !== 'undefined' && swpdDesignerConfig.debug)) {
        console.log(`[SWPD] ${message}`, data || '');
      }
  }

  createFallbackLightbox() {
    return this.imageLoader.createFallbackLightbox();
  }

  cleanup() {
    // Remove event listeners
    window.onbeforeunload = null;

    // Clear intervals
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }

    // Clear canvas
    if (this.canvas) {
      this.canvas.dispose();
      this.canvas = null;
    }

    // Clear references
    this.backgroundImage = null;
    this.maskImage = null;
    this.history = [];
    this.savedDesigns = [];
  }

  // Add placeholder methods for missing functions
  loadFabricJS() {
    return new Promise((resolve) => {
      if (typeof fabric !== 'undefined') {
        resolve();
      } else {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js';
        script.onload = resolve;
        document.head.appendChild(script);
      }
    });
  }

  loadCropperJS() {
    return new Promise((resolve) => {
      if (typeof Cropper !== 'undefined') {
        resolve();
      } else {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css';
        document.head.appendChild(link);

        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js';
        script.onload = resolve;
        document.head.appendChild(script);
      }
    });
  }

  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

      // Existing shortcuts
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        this.undo();
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        this.redo();
      }
      if (e.key === 'Delete' || e.key === 'Backspace') {
        const activeObject = this.canvas?.getActiveObject();
        if (activeObject && activeObject !== this.backgroundImage && activeObject !== this.maskImage && activeObject !== this.unclippedMaskImage) {
          this.canvas.remove(activeObject);
          this.ensureProperLayering();
          this.saveHistory();
          this.showNotification('Item deleted');
        }
      }

      // New shortcuts
      if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
        e.preventDefault();
        this.groupSelectedObjects();
      }
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'G') {
        e.preventDefault();
        this.ungroupSelectedObject();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
        e.preventDefault();
        this.selectAll();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        this.duplicateSelection();
      }

      // Arrow key nudging
      const activeObject = this.canvas?.getActiveObject();
      if (activeObject && activeObject.selectable) {
        const nudgeAmount = e.shiftKey ? 10 : 1;

        switch(e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            activeObject.left -= nudgeAmount;
            break;
          case 'ArrowRight':
            e.preventDefault();
            activeObject.left += nudgeAmount;
            break;
          case 'ArrowUp':
            e.preventDefault();
            activeObject.top -= nudgeAmount;
            break;
          case 'ArrowDown':
            e.preventDefault();
            activeObject.top += nudgeAmount;
            break;
        }

        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
          activeObject.setCoords();
          this.canvas.renderAll();
          this.saveHistory();
        }
      }
    });
  }

  async applyDesign() {
    if (!this.canvas) return;

    this.showNotification('Processing design...', 'info');
    const preview = await this.generatePreview();
    const uploadResult = await this.uploadPreviewToWordPress(preview);

    let wpPreviewUrl = typeof uploadResult === 'string' ? uploadResult : (uploadResult.url || preview);

    const canvasData = JSON.stringify({
        objects: this.canvas.getObjects().filter(obj => obj.selectable !== false).map(obj => obj.toObject(['selectable', 'evented', 'crossOrigin']))
    });

    document.getElementById('custom-design-preview').value = wpPreviewUrl;
    document.getElementById('custom-design-data').value = JSON.stringify({
        hasCustomDesign: true,
        elementCount: this.canvas.getObjects().filter(obj => obj.selectable !== false).length,
        timestamp: Date.now()
    });
    document.getElementById('custom-canvas-data').value = canvasData;

    // Update product image on the page
    const mainImage = document.querySelector('.woocommerce-product-gallery__image img');
    if (mainImage) {
      mainImage.src = wpPreviewUrl;
      mainImage.srcset = '';
    }

    this.updateUIAfterDesign();
    this.showNotification('Design applied!');

    // Close lightbox but also add a parameter to the URL to signify a design was just applied.
    this.closeLightbox();
    setTimeout(() => {
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('design_applied', '1');
        // A soft reload is better here to ensure all WooCommerce scripts update correctly
        window.location.href = currentUrl.toString();
    }, 100);
  }

  async addToCart() {
    console.log('=== ADD TO CART DEBUG ===');

    if (!this.canvas) {
      console.error('Canvas not available');
      return;
    }

    const addToCartBtn = document.querySelector('.add-to-cart-design');
    let originalButtonHTML = '';
    if (addToCartBtn) {
      originalButtonHTML = addToCartBtn.innerHTML;
    }

    this.showNotification('Preparing your design...', 'info');

    // Generate and upload preview
    const preview = await this.generatePreview();
    console.log('Generated preview, size:', Math.round(preview.length * 0.75 / 1024), 'KB');

    const uploadResult = await this.uploadPreviewToWordPress(preview);
    console.log('Upload result type:', typeof uploadResult);

    // Extract the URL from the result object
    let wpPreviewUrl;
    if (typeof uploadResult === 'object' && uploadResult.url) {
      wpPreviewUrl = uploadResult.url;
    } else if (typeof uploadResult === 'string') {
      wpPreviewUrl = uploadResult;
    } else {
      console.error('Invalid preview upload result:', uploadResult);
      this.showNotification('Error processing preview image', 'error');
      return;
    }

    console.log('Final preview URL:', wpPreviewUrl);

    const canvasData = JSON.parse(JSON.stringify({objects: this.canvas.getObjects().filter(obj => obj.selectable !== false).map(obj => obj.toObject(['selectable', 'evented', 'crossOrigin']))}));

    // Set form data
    const previewInput = document.getElementById('custom-design-preview');
    const dataInput = document.getElementById('custom-design-data');
    const canvasInput = document.getElementById('custom-canvas-data');

    if (previewInput) {
      previewInput.value = wpPreviewUrl;
      console.log('Set preview input value:', wpPreviewUrl);
    }

    if (dataInput) {
      const designData = JSON.stringify({
        hasCustomDesign: true,
        designCount: this.canvas.getObjects().filter(obj => obj.selectable !== false).length,
        timestamp: Date.now(),
        previewUrl: wpPreviewUrl // Add preview URL to design data
      });
      dataInput.value = designData;
      console.log('Set design data:', designData);
    }

    if (canvasInput) {
      canvasInput.value = JSON.stringify(canvasData);
      console.log('Set canvas data, objects:', canvasData.objects.length);
    }

    // Update the main product image to show the design
    const productImages = document.querySelectorAll('.product-gallery__image img, .product__media-image, .product-single__photo img, .woocommerce-product-gallery__image img');
    console.log('Found product images to update:', productImages.length);

    productImages.forEach((img, index) => {
      if (img) {
        if (!img.dataset.originalSrc) {
          img.dataset.originalSrc = img.src;
          img.dataset.originalSrcset = img.srcset || '';
        }
        img.src = wpPreviewUrl;
        img.removeAttribute('srcset');
        console.log(`Updated product image ${index + 1}`);
      }
    });

    // Add the swpd-design-applied class
    document.body.classList.add('swpd-design-applied');

    this.saveSessionDesign();
    sessionStorage.removeItem('designer_session_' + this.currentVariantId);

    // Store preview URL for cart processing
    sessionStorage.setItem('swpd_cart_preview_url', wpPreviewUrl);
    sessionStorage.setItem('swpd_cart_canvas_data', JSON.stringify(canvasData));

    // Close the lightbox
    this.closeLightbox();

    // Wait a moment for the DOM to update, then submit the form
    setTimeout(() => {
      const productForm = document.querySelector('form.cart') || document.querySelector('.product-form form');
      if (!productForm) {
        console.error('Product form not found for add to cart action.');
        this.showNotification('Error: Could not find product form. Please click Add to Cart manually.', 'error');
        return;
      }

      console.log('Submitting product form...');
      console.log('Form action:', productForm.action);
      console.log('Form method:', productForm.method);

      // Find and click the actual add to cart button
      const originalAddToCartButton = productForm.querySelector('button[name="add-to-cart"]:not(#swpd-customize-design-button), button[type="submit"]:not(#swpd-customize-design-button)');
      if (originalAddToCartButton) {
        this.showNotification('Adding to cart...');
        console.log('Clicking add to cart button');
        originalAddToCartButton.click();
      } else {
        // Fallback: submit the form directly
        console.log('No add to cart button found, submitting form directly');
        productForm.submit();
      }
    }, 500);

    console.log('=== END ADD TO CART DEBUG ===');
  }

  showSavedDesigns() {
    const designs = this.savedDesigns.filter(d => d.variantId == this.currentVariantId);
    if (designs.length === 0) {
      this.showNotification('No saved designs for this product variant.');
      return;
    }
    const modal = document.createElement('div');
    modal.className = 'saved-designs-modal';
    modal.innerHTML = `
      <div class="saved-designs-content">
        <h3>Load Saved Design</h3>
        <div class="designs-grid">
          ${designs.map((design, index) => `
            <div class="design-item" data-index="${index}">
              <h4>${design.name}</h4>
              <p>${new Date(design.date).toLocaleDateString()}</p>
              <button class="btn load-this-design">Load</button>
              <button class="btn btn-danger delete-this-design">Delete</button>
            </div>
          `).join('')}
        </div>
        <button class="btn btn-secondary close-saved-designs">Close</button>
      </div>
    `;
    document.body.appendChild(modal);
    modal.style.display = 'flex';

    modal.querySelectorAll('.load-this-design').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = e.target.closest('.design-item').dataset.index;
        this.loadSavedDesign(designs[index]);
        document.body.removeChild(modal);
      });
    });
    modal.querySelectorAll('.delete-this-design').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = e.target.closest('.design-item').dataset.index;
        const designToDelete = designs[index];

        this.showConfirmationModal(`Delete design "${designToDelete.name}"?`, () => {
          this.savedDesigns = this.savedDesigns.filter((d, i) =>
            !(d.name === designToDelete.name && d.variantId == designToDelete.variantId && d.date === designToDelete.date)
          );
          localStorage.setItem('customDesigns', JSON.stringify(this.savedDesigns));
          document.body.removeChild(modal);
          this.showSavedDesigns();
          this.showNotification('Design deleted.');
        });
      });
    });
    modal.querySelector('.close-saved-designs')?.addEventListener('click', () => {
      document.body.removeChild(modal);
    });
  }

  showHelp() {
    const modal = document.createElement('div');
    modal.className = 'help-modal';
    modal.innerHTML = `
      <div class="help-content">
        <h3>Keyboard Shortcuts</h3>
        <div class="help-sections">
          <div class="help-section">
            <div class="shortcuts-list">
              <div class="shortcut-item">
                <span class="shortcut-keys">Ctrl/Cmd + Z</span>
                <span class="shortcut-desc">Undo</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Ctrl/Cmd + Y</span>
                <span class="shortcut-desc">Redo</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Delete</span>
                <span class="shortcut-desc">Delete selected</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Ctrl/Cmd + A</span>
                <span class="shortcut-desc">Select all</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Ctrl/Cmd + D</span>
                <span class="shortcut-desc">Duplicate</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Ctrl/Cmd + G</span>
                <span class="shortcut-desc">Group</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Arrow Keys</span>
                <span class="shortcut-desc">Nudge 1px</span>
              </div>
              <div class="shortcut-item">
                <span class="shortcut-keys">Shift + Arrow</span>
                <span class="shortcut-desc">Nudge 10px</span>
              </div>
            </div>
          </div>
          <div class="help-section">
            <h4>Tips:</h4>
            <ul>
              <li>Click on the canvas background to deselect all items</li>
              <li>Hold Shift while resizing to maintain aspect ratio</li>
              <li>Use the layers panel to reorder elements</li>
              <li>Double-click text to edit it inline</li>
              <li>Scroll to zoom in/out when hovering over the canvas</li>
            </ul>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn btn-primary close-help">Got it!</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    modal.style.display = 'flex';

    modal.querySelector('.close-help').addEventListener('click', () => {
      modal.style.display = 'none';
      setTimeout(() => document.body.removeChild(modal), 300);
    });

    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.style.display = 'none';
        setTimeout(() => document.body.removeChild(modal), 300);
      }
    });
  }

  showTemplatesModal() {
    const modal = document.createElement('div');
    modal.className = 'templates-modal mobile-optimized';
    modal.innerHTML = `
      <div class="templates-content">
        <div class="templates-header">
          <h3>${this.translations?.chooseTemplate || 'Choose a Template'}</h3>
          <button class="close-modal">&times;</button>
        </div>
        <div class="template-categories">
          <button class="category-btn active" data-category="all">All</button>
          <button class="category-btn" data-category="birthday">Birthday</button>
          <button class="category-btn" data-category="wedding">Wedding</button>
          <button class="category-btn" data-category="sports">Sports</button>
        </div>
        <div class="templates-grid mobile-grid">
                            </div>
      </div>
    `;

    document.body.appendChild(modal);
    modal.style.display = 'flex';

    // Add mobile-specific styles
    const style = document.createElement('style');
    style.textContent = `
      .templates-modal.mobile-optimized .templates-content {
        width: 100%;
        height: 100vh;
        max-height: 100vh;
        margin: 0;
        border-radius: 0;
        display: flex;
        flex-direction: column;
      }
      .templates-modal.mobile-optimized .templates-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px;
        border-bottom: 1px solid var(--swpd-border);
        background: #fff;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .templates-modal.mobile-optimized .templates-header h3 {
        margin: 0;
        font-size: 1.1rem;
      }
      .templates-modal.mobile-optimized .close-modal {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 4px;
      }
      .templates-modal.mobile-optimized .template-categories {
        padding: 12px;
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
        background: #f5f5f5;
      }
      .templates-modal.mobile-optimized .templates-grid.mobile-grid {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
      .templates-modal.mobile-optimized .template-item {
        padding: 8px;
      }
      .templates-modal.mobile-optimized .template-item img {
        height: 120px;
      }
    `;
    document.head.appendChild(style);

    // Load templates (mock data for now)
    const templatesGrid = modal.querySelector('.templates-grid');
    const mockTemplates = [
      { name: 'Birthday Balloons', category: 'birthday', preview: 'balloon-icon' },
      { name: 'Wedding Elegant', category: 'wedding', preview: 'heart-icon' },
      { name: 'Team Spirit', category: 'sports', preview: 'star-icon' }
    ];

    mockTemplates.forEach(template => {
      const item = document.createElement('div');
      item.className = 'template-item';
      item.innerHTML = `
        <div style="background: #f0f0f0; height: 120px; display: flex; align-items: center; justify-content: center; border-radius: 8px;">
          <svg width="60" height="60" fill="var(--swpd-primary)" opacity="0.5">
            <circle cx="30" cy="30" r="25"/>
          </svg>
        </div>
        <p style="margin: 8px 0 0; font-size: 0.9rem;">${template.name}</p>
      `;
      item.addEventListener('click', () => {
        // Apply template logic here
        this.showNotification('Template applied!');
        modal.remove();
        style.remove();
      });
      templatesGrid.appendChild(item);
    });

    // Category filter
    modal.querySelectorAll('.category-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        modal.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        // Filter logic here
      });
    });

    // Close button
    modal.querySelector('.close-modal').addEventListener('click', () => {
      modal.remove();
      style.remove();
    });
  }

  setupTouchGestures() {
    // Placeholder for touch gestures
  }

  setupMobileEventHandlers() {
    // Placeholder for mobile event handlers
  }
}

// Initialize the designer and set up event handlers when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Initialize the designer if config is available
    if (typeof swpdDesignerConfig !== 'undefined') {
        try {
            window.customDesigner = new EnhancedProductDesigner(swpdDesignerConfig);
        } catch (error) {
            console.error('Error initializing custom designer:', error);
        }
    } else {
        console.warn('swpdDesignerConfig not found. Custom designer not initialized.');
    }

    // Add event listener for the product page's "Customize Design" button
    document.body.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'swpd-customize-design-button') {
            e.preventDefault();
            console.log('Customize Design button clicked!');

            if (window.customDesigner) {
                var productId = swpdDesignerConfig.product_id;
                var variantId = productId;

                // For variable products, find the currently selected variation ID
                var variationInput = document.querySelector('input[name="variation_id"]');
                if (variationInput && variationInput.value > 0) {
                    variantId = variationInput.value;
                }

                if (variantId) {
                    try {
                        window.customDesigner.openLightbox(variantId);
                    } catch (error) {
                        console.error('Error calling openLightbox:', error);
                        alert('Error opening designer: ' + error.message);
                    }
                } else {
                    alert('Please select product options before customizing.');
                }
            } else {
                console.error('Designer not initialized.');
                alert('Designer could not be opened. Please refresh the page and try again.');
            }
        }
    });

    // Global handler for "Edit Design" buttons in the cart
    document.body.addEventListener('click', function(e) {
        if (e.target && e.target.matches('.swpd-edit-design-button')) {
            e.preventDefault();
            console.log('Edit design handler triggered');

            const button = e.target;
            const productUrl = button.dataset.productUrl;
            const variantId = button.dataset.variantId;
            const cartKey = button.id ? button.id.replace('swpd-edit-', '') : null;

            if (cartKey && window.swpdCanvasData && window.swpdCanvasData[cartKey]) {
                let canvasData = window.swpdCanvasData[cartKey];
                if (typeof canvasData !== 'string') {
                    canvasData = JSON.stringify(canvasData);
                }

                sessionStorage.setItem('edit_design_data', canvasData);
                sessionStorage.setItem('edit_design_variant', variantId.toString());
                sessionStorage.setItem('edit_cart_key', cartKey);

                window.location.href = productUrl + '?edit_design=1&variant=' + variantId;
            } else {
                console.error('Could not find canvas data');
                alert('Unable to load design data. Please refresh the page and try again.');
            }
        }
    });

    // Automatically open designer if in edit mode
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('edit_design') === '1') {
        let attempts = 0;
        const initInterval = setInterval(() => {
            if (window.customDesigner && typeof window.customDesigner.openLightbox === 'function') {
                clearInterval(initInterval);
                const variantId = urlParams.get('variant');
                console.log('Auto-opening designer for edit mode.');
                window.customDesigner.openLightbox(variantId);
                // Clean up the URL
                const cleanUrl = window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);
            } else if (++attempts > 50) { // 5-second timeout
                clearInterval(initInterval);
                console.error("Designer didn't initialize for auto-open.");
            }
        }, 100);
    }
});

// Make constructor available globally
window.EnhancedProductDesigner = EnhancedProductDesigner;

} // End of duplicate prevention wrapper